package com.example.guessthewordsgame.presentation.test

import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.core.FastOutSlowInEasing
import androidx.compose.animation.core.LinearEasing
import androidx.compose.animation.core.RepeatMode
import androidx.compose.animation.core.animate
import androidx.compose.animation.core.animateFloat
import androidx.compose.animation.core.animateFloatAsState
import androidx.compose.animation.core.infiniteRepeatable
import androidx.compose.animation.core.rememberInfiniteTransition
import androidx.compose.animation.core.tween
import androidx.compose.animation.fadeIn
import androidx.compose.animation.fadeOut
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.offset
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.layout.wrapContentHeight
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.Check
import androidx.compose.material.icons.filled.Close
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Snackbar
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.CompositionLocalProvider
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateMapOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.scale
import androidx.compose.ui.draw.shadow
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Shadow
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.layout.onGloballyPositioned
import androidx.compose.ui.layout.positionInWindow
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.platform.LocalLayoutDirection
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.Font
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.IntSize
import androidx.compose.ui.unit.LayoutDirection
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.pyramid.questions.Rimport com.example.guessthewordsgame.presentation.game.GameDataManager
import com.example.guessthewordsgame.presentation.game.LetterData
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch

data class LetterPosition(
    val letter: String,
    var startPosition: Offset = Offset.Zero,
    var endPosition: Offset = Offset.Zero,
    var size: IntSize = IntSize.Zero
)

@Composable
fun WordGuessingGameApp() {
    CompositionLocalProvider(LocalLayoutDirection provides LayoutDirection.Rtl) {
        WordGuessingGame()
    }
}

@Composable
fun WordGuessingGame() {
    val gameDataManager = remember { GameDataManager() }
    val gameData = gameDataManager.getGameData()
    val coroutineScope = rememberCoroutineScope()
    val density = LocalDensity.current

    var showSuccess by remember { mutableStateOf(gameDataManager.getShowSuccess()) }
    var showError by remember { mutableStateOf(gameDataManager.getShowError()) }
    var showHint by remember { mutableStateOf(gameDataManager.getShowHint()) }
    var isDeleteRandomEnabled by remember { mutableStateOf(true) }

    var movingLetter by remember { mutableStateOf<LetterData?>(null) }
    val availableLettersPositions = remember { mutableStateMapOf<Int, LetterPosition>() }
    val answerPositions = remember { mutableStateMapOf<Int, LetterPosition>() }

    var animatedPosition by remember { mutableStateOf(Offset.Zero) }
    var letterSourcePosition by remember { mutableStateOf(Offset.Zero) }
    var letterTargetPosition by remember { mutableStateOf(Offset.Zero) }

    var isLetterMoving by remember { mutableStateOf(false) }
    var movingLetterIndex by remember { mutableStateOf(-1) }
    var targetLetterIndex by remember { mutableStateOf(-1) }

    var pendingLetter by remember { mutableStateOf<Pair<Int, LetterData>?>(null) }

    // إضافة استماع للتغييرات في البيانات
    LaunchedEffect(gameData) {
        showSuccess = gameDataManager.getShowSuccess()
        showError = gameDataManager.getShowError()
        showHint = gameDataManager.getShowHint()
    }

    LaunchedEffect(showSuccess) {
        if (showSuccess) {
            delay(2000)
            gameDataManager.setShowSuccess(false)
            showSuccess = false
        }
    }

    LaunchedEffect(showError) {
        if (showError) {
            delay(1500)
            gameDataManager.setShowError(false)
            showError = false
        }
    }

    LaunchedEffect(showHint) {
        if (showHint) {
            delay(3000)
            gameDataManager.setShowHint(false)
            showHint = false
        }
    }

    val infiniteTransition = rememberInfiniteTransition(label = "background")
    val backgroundAlpha by infiniteTransition.animateFloat(
        initialValue = 0.7f,
        targetValue = 0.9f,
        animationSpec = infiniteRepeatable(
            animation = tween(2000, easing = LinearEasing),
            repeatMode = RepeatMode.Reverse
        ),
        label = "alpha"
    )

    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(Color(0xFF0C1638))
    ) {
        Column(
            modifier = Modifier.fillMaxSize()
        ) {
            Box(
                modifier = Modifier
                    .weight(1f)
                    .fillMaxWidth()
            ) {
                Image(
                    painter = painterResource(id = R.drawable.japanese_background),
                    contentDescription = "Japanese Background Above Question",
                    modifier = Modifier
                        .fillMaxSize()
                        .graphicsLayer(alpha = 0.4f),
                    contentScale = ContentScale.Crop
                )
                TopBar(
                    score = gameData.score,
                    onBackClick = { /* يمكن تنفيذ الرجوع هنا */ }
                )
                ProgressIndicator(
                    currentLevel = gameData.level,
                    maxLevel = gameData.maxLevel,
                    modifier = Modifier
                        .align(Alignment.CenterStart)
                        .padding(start = 16.dp)
                )

                Box(
                    modifier = Modifier
                        .align(Alignment.Center)
                        .size(200.dp)
                        .padding(bottom = 32.dp)
                ) {
                    Column {
                        AnimatedVisibility(
                            visible = showHint,
                            enter = fadeIn(animationSpec = tween(300)),
                            exit = fadeOut(animationSpec = tween(300))
                        ) {
                            Image(
                                painter = painterResource(id = gameData.hintImageResId),
                                contentDescription = "Country Hint",
                                modifier = Modifier
                                    .fillMaxSize()
                                    .clip(RoundedCornerShape(16.dp))
                                    .border(2.dp, Color.White, RoundedCornerShape(16.dp))
                            )
                        }
                    }
                }
            }

            QuestionBar()

            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .height(280.dp)
                    .background(
                        Brush.verticalGradient(
                            colors = listOf(Color(0xFF13277A), Color(0xFF0E1E58))
                        )
                    ),
                contentAlignment = Alignment.Center
            ) {
                // منطقة التخمين المعدلة
                Column(
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.spacedBy(16.dp),
                    modifier = Modifier.padding(vertical = 16.dp)
                ) {
                    // صف الأحرف المختارة (مكان الإجابة)
                    Row(
                        horizontalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        for (i in gameData.targetWord.indices) {
                            val hasLetter = i < gameData.selectedLetters.size
                            val isTargetForMovingLetter = isLetterMoving && targetLetterIndex == i

                            Box(
                                modifier = Modifier
                                    .size(44.dp)
                                    .clip(RoundedCornerShape(8.dp))
                                    .background(
                                        if (hasLetter || isTargetForMovingLetter) Color.White
                                        else Color(0xFF3A5498)
                                    )
                                    .border(1.dp, Color(0xFF5270BF), RoundedCornerShape(8.dp))
                                    .onGloballyPositioned { coordinates ->
                                        answerPositions[i] = LetterPosition(
                                            letter = if (hasLetter) gameData.selectedLetters[i].letter.toString() else "",
                                            startPosition = coordinates.positionInWindow(),
                                            size = coordinates.size
                                        )
                                    },
                                contentAlignment = Alignment.Center
                            ) {
                                if (hasLetter && !isTargetForMovingLetter) {
                                    Text(
                                        text = gameData.selectedLetters[i].letter.toString(),
                                        color = Color.Black,
                                        fontSize = 24.sp,
                                        fontFamily = FontFamily(Font(R.font.arbic_font_bold_2)),
                                        fontWeight = FontWeight.Bold
                                    )
                                }

                                if (pendingLetter != null && pendingLetter!!.first == i && !isLetterMoving) {
                                    Text(
                                        text = pendingLetter!!.second.letter.toString(),
                                        color = Color.Black,
                                        fontSize = 24.sp,
                                        fontFamily = FontFamily(Font(R.font.arbic_font_bold_2)),
                                        fontWeight = FontWeight.Bold
                                    )
                                }
                            }
                        }
                    }

                    // صفوف الأحرف المتاحة
                    Column(
                        verticalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        // صف أول من الأحرف المتاحة
                        Row(
                            horizontalArrangement = Arrangement.spacedBy(8.dp)
                        ) {
                            for (i in 0 until 5) {
                                if (i < gameData.availableLetters.size) {
                                    val letter = gameData.availableLetters[i]
                                    if (isLetterMoving && movingLetterIndex == i) {
                                        Box(
                                            modifier = Modifier.size(48.dp)
                                        )
                                    } else {
                                        ArabicLetterButtonWithPosition(
                                            letter = letter.letter.toString(),
                                            onClick = {
                                                if (!letter.isSelected && !letter.isDeleted) {
                                                    // تحريك الحرف
                                                    moveLetter(
                                                        letterIndex = i,
                                                        letter = letter,
                                                        coroutineScope = coroutineScope,
                                                        gameDataManager = gameDataManager,
                                                        availableLettersPositions = availableLettersPositions,
                                                        answerPositions = answerPositions,
                                                        setMovingLetterIndex = { movingLetterIndex = it },
                                                        setTargetLetterIndex = { targetLetterIndex = it },
                                                        setLetterSourcePosition = { letterSourcePosition = it },
                                                        setLetterTargetPosition = { letterTargetPosition = it },
                                                        setIsLetterMoving = { isLetterMoving = it },
                                                        setMovingLetter = { movingLetter = it },
                                                        setPendingLetter = { pendingLetter = it },
                                                        setAnimatedPosition = { animatedPosition = it },
                                                        updateSuccess = { showSuccess = it },
                                                        updateError = { showError = it }
                                                    )
                                                }
                                            },
                                            isSelected = letter.isSelected,
                                            isDeleted = letter.isDeleted,
                                            onPositionCaptured = { position, size ->
                                                availableLettersPositions[i] = LetterPosition(
                                                    letter = letter.letter.toString(),
                                                    startPosition = position,
                                                    size = size
                                                )
                                            }
                                        )
                                    }
                                }
                            }
                        }

                        // صف ثاني من الأحرف المتاحة
                        Row(
                            horizontalArrangement = Arrangement.spacedBy(8.dp)
                        ) {
                            for (i in 5 until gameData.availableLetters.size) {
                                val letter = gameData.availableLetters[i]
                                if (isLetterMoving && movingLetterIndex == i) {
                                    Box(
                                        modifier = Modifier.size(48.dp)
                                    )
                                } else {
                                    ArabicLetterButtonWithPosition(
                                        letter = letter.letter.toString(),
                                        onClick = {
                                            if (!letter.isSelected && !letter.isDeleted) {
                                                // تحريك الحرف
                                                moveLetter(
                                                    letterIndex = i,
                                                    letter = letter,
                                                    coroutineScope = coroutineScope,
                                                    gameDataManager = gameDataManager,
                                                    availableLettersPositions = availableLettersPositions,
                                                    answerPositions = answerPositions,
                                                    setMovingLetterIndex = { movingLetterIndex = it },
                                                    setTargetLetterIndex = { targetLetterIndex = it },
                                                    setLetterSourcePosition = { letterSourcePosition = it },
                                                    setLetterTargetPosition = { letterTargetPosition = it },
                                                    setIsLetterMoving = { isLetterMoving = it },
                                                    setMovingLetter = { movingLetter = it },
                                                    setPendingLetter = { pendingLetter = it },
                                                    setAnimatedPosition = { animatedPosition = it },
                                                    updateSuccess = { showSuccess = it },
                                                    updateError = { showError = it }
                                                )
                                            }
                                        },
                                        isSelected = letter.isSelected,
                                        isDeleted = letter.isDeleted,
                                        onPositionCaptured = { position, size ->
                                            availableLettersPositions[i] = LetterPosition(
                                                letter = letter.letter.toString(),
                                                startPosition = position,
                                                size = size
                                            )
                                        }
                                    )
                                }
                            }
                        }
                    }
                }

                // عرض الحرف المتحرك
                if (isLetterMoving && movingLetter != null) {
                    Box(
                        modifier = Modifier
                            .size(48.dp)
                            .offset(
                                x = with(density) { (animatedPosition.x / density.density).dp },
                                y = with(density) { (animatedPosition.y / density.density).dp }
                            )
                            .background(Color.White, RoundedCornerShape(8.dp))
                            .border(1.5.dp, Color(0xFF5270BF), RoundedCornerShape(8.dp)),
                        contentAlignment = Alignment.Center
                    ) {
                        Text(
                            text = movingLetter!!.letter.toString(),
                            color = Color.Black,
                            fontSize = 26.sp,
                            fontFamily = FontFamily(Font(R.font.arbic_font_bold_2)),
                            fontWeight = FontWeight.Bold,
                            textAlign = TextAlign.Center
                        )
                    }
                }
            }

            ControlButtons(
                onHintClick = {
                    gameDataManager.showHint()
                    showHint = true
                },
                onSkipClick = {
                    gameDataManager.skipWord()
                },
                onDeleteLetter = {
                    gameDataManager.deleteLetter()
                },
                onClearAll = {
                    gameDataManager.clearAllLetters()
                },
                onDeleteRandomLetters = {
                    if (isDeleteRandomEnabled) {
                        gameDataManager.deleteRandomLetters(2)
                        isDeleteRandomEnabled = false
                    }
                },
                isDeleteRandomEnabled = isDeleteRandomEnabled
            )
        }

        AnimatedVisibility(
            visible = showSuccess,
            modifier = Modifier
                .align(Alignment.Center)
        ) {
            SuccessMessage(score = 50)
        }

        AnimatedVisibility(
            visible = showError,
            modifier = Modifier
                .align(Alignment.Center)
        ) {
            ErrorMessage()
        }

        if (showHint && gameData.hintText.isNotEmpty()) {
            Box(
                modifier = Modifier
                    .align(Alignment.TopCenter)
                    .padding(top = 80.dp)
            ) {
                Snackbar(
                    modifier = Modifier
                        .padding(16.dp)
                ) {
                    Text(
                        text = gameData.hintText,
                        textAlign = TextAlign.Center,
                        fontFamily = FontFamily(Font(R.font.arbic_font_bold_2))
                    )
                }
            }
        }
    }
}

// دالة منفصلة لتحريك الحروف للحفاظ على بساطة الكود
private fun moveLetter(
    letterIndex: Int,
    letter: LetterData,
    coroutineScope: kotlinx.coroutines.CoroutineScope,
    gameDataManager: GameDataManager,
    availableLettersPositions: Map<Int, LetterPosition>,
    answerPositions: Map<Int, LetterPosition>,
    setMovingLetterIndex: (Int) -> Unit,
    setTargetLetterIndex: (Int) -> Unit,
    setLetterSourcePosition: (Offset) -> Unit,
    setLetterTargetPosition: (Offset) -> Unit,
    setIsLetterMoving: (Boolean) -> Unit,
    setMovingLetter: (LetterData?) -> Unit,
    setPendingLetter: (Pair<Int, LetterData>?) -> Unit,
    setAnimatedPosition: (Offset) -> Unit,
    updateSuccess: (Boolean) -> Unit,
    updateError: (Boolean) -> Unit
) {
    // حفظ مؤشر الحرف المتحرك
    setMovingLetterIndex(letterIndex)

    // تحديد الموقع المستهدف (أول مكان متاح في الإجابة)
    val targetIndex = gameDataManager.getGameData().selectedLetters.size
    setTargetLetterIndex(targetIndex)

    // حفظ موقع البداية والنهاية للحركة
    setLetterSourcePosition(availableLettersPositions[letterIndex]?.startPosition ?: Offset.Zero)
    setLetterTargetPosition(answerPositions[targetIndex]?.startPosition ?: Offset.Zero)

    // بدء الحركة
    setIsLetterMoving(true)
    setMovingLetter(letter)

    // إعداد الحرف المعلّق للموقع المستهدف
    setPendingLetter(Pair(targetIndex, letter))

    // تشغيل الحركة
    coroutineScope.launch {
        animatePosition(
            startPosition = availableLettersPositions[letterIndex]?.startPosition ?: Offset.Zero,
            endPosition = answerPositions[targetIndex]?.startPosition ?: Offset.Zero
        ) { currentPosition ->
            setAnimatedPosition(currentPosition)
        }

        // انتهاء الحركة - تنفيذ اختيار الحرف
        setIsLetterMoving(false)
        setMovingLetter(null)

        // إضافة الحرف إلى المصفوفة الفعلية
        gameDataManager.selectLetter(letter)

        // مسح الحرف المعلق بعد إكمال الإجراء
        delay(100) // تأخير بسيط للانتقال الناعم
        setPendingLetter(null)

        updateSuccess(gameDataManager.getShowSuccess())
        updateError(gameDataManager.getShowError())
    }
}

// تحسين دالة الحركة لتكون أكثر سلاسة
suspend fun animatePosition(
    startPosition: Offset,
    endPosition: Offset,
    updatePosition: (Offset) -> Unit
) {
    val animationSpec = tween<Float>(
        durationMillis = 250, // تقليل المدة لتكون أسرع
        easing = FastOutSlowInEasing
    )

    animate(
        initialValue = 0f,
        targetValue = 1f,
        animationSpec = animationSpec
    ) { value, _ ->
        val x = startPosition.x + (endPosition.x - startPosition.x) * value
        val y = startPosition.y + (endPosition.y - startPosition.y) * value
        updatePosition(Offset(x, y))
    }
}

@Composable
fun ArabicLetterButtonWithPosition(
    letter: String,
    onClick: () -> Unit,
    isSelected: Boolean = false,
    isDeleted: Boolean = false,
    onPositionCaptured: (Offset, IntSize) -> Unit
) {
    val infiniteTransition = rememberInfiniteTransition(label = "pulse")
    val scale by infiniteTransition.animateFloat(
        initialValue = 1f,
        targetValue = if (!isSelected && !isDeleted) 1.05f else 1f,
        animationSpec = infiniteRepeatable(
            animation = tween(1000, easing = LinearEasing),
            repeatMode = RepeatMode.Reverse
        ),
        label = "scale"
    )

    Box(
        modifier = Modifier
            .size(48.dp)
            .scale(scale)
            .shadow(4.dp, RoundedCornerShape(8.dp))
            .clip(RoundedCornerShape(8.dp))
            .background(
                when {
                    isDeleted -> Brush.radialGradient(
                        colors = listOf(
                            Color(0x44CCCCCC),
                            Color(0x44CCCCCC)
                        )
                    )
                    isSelected -> Brush.radialGradient(
                        colors = listOf(
                            Color(0xFF0E1E58),
                            Color(0xFF0E1E58)
                        )
                    )
                    else -> Brush.radialGradient(
                        colors = listOf(Color.White, Color(0xFFF0F0F0))
                    )
                }
            )
            .border(1.dp, if (!isSelected && !isDeleted) Color(0xFF5270BF) else Color.Transparent, RoundedCornerShape(8.dp))
            .clickable(
                enabled = !isSelected && !isDeleted,
                onClick = onClick
            )
            .onGloballyPositioned { coordinates ->
                // حفظ موقع الزر في النافذة
                onPositionCaptured(coordinates.positionInWindow(), coordinates.size)
            },
        contentAlignment = Alignment.Center
    ) {
        Text(
            text = if (isDeleted) "" else letter,
            color = if (isSelected)
                Color(0xFF0E1E58) else Color.Black,
            fontSize = 26.sp,
            fontFamily = FontFamily(Font(R.font.arbic_font_bold_2)),
            fontWeight = FontWeight.Bold,
            textAlign = TextAlign.Center
        )
    }
}

@Composable
fun ControlButton(
    iconRes: Int,
    backgroundColor: Color,
    onClick: () -> Unit,
    label: String,
    enabled: Boolean = true
) {
    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        modifier = Modifier.padding(4.dp)
    ) {
        val infiniteTransition = rememberInfiniteTransition(label = "pulse")
        val scale by infiniteTransition.animateFloat(
            initialValue = 1f,
            targetValue = if (enabled) 1.05f else 1f,
            animationSpec = infiniteRepeatable(
                animation = tween(1200, easing = LinearEasing),
                repeatMode = RepeatMode.Reverse
            ),
            label = "scale"
        )

        Box(
            modifier = Modifier
                .size(52.dp)
                .scale(scale)
                .shadow(8.dp, RoundedCornerShape(12.dp))
                .clip(RoundedCornerShape(12.dp))
                .border(
                    width = 1.5.dp,
                    brush = Brush.radialGradient(
                        colors = listOf(
                            Color.White.copy(alpha = 0.7f),
                            if (enabled) backgroundColor else backgroundColor.copy(alpha = 0.3f)
                        )
                    ),
                    shape = RoundedCornerShape(12.dp)
                )
                .background(
                    Brush.radialGradient(
                        colors = listOf(
                            if (enabled) backgroundColor else backgroundColor.copy(alpha = 0.5f),
                            if (enabled) backgroundColor.copy(alpha = 0.8f) else backgroundColor.copy(alpha = 0.3f)
                        )
                    )
                )
                // تغيير الـ clickable لتحسين الاستجابة
                .clickable(enabled = enabled, onClick = onClick),
            contentAlignment = Alignment.Center
        ) {
            // هالة حول الأيقونة
            Box(
                modifier = Modifier
                    .size(44.dp)
                    .clip(CircleShape)
                    .background(
                        Brush.radialGradient(
                            colors = listOf(
                                backgroundColor.copy(alpha = 0.0f),
                                backgroundColor
                            )
                        )
                    ),
                contentAlignment = Alignment.Center
            ) {
                Image(
                    painter = painterResource(id = iconRes),
                    contentDescription = label,
                    modifier = Modifier
                        .size(28.dp)
                        .graphicsLayer {
                            alpha = if (enabled) 1f else 0.6f
                        }
                )
            }
        }

        Text(
            text = label,
            color = Color.White,
            fontSize = 14.sp,
            fontWeight = FontWeight.Bold,
            modifier = Modifier.padding(top = 6.dp),
            fontFamily = FontFamily(Font(R.font.arbic_font_bold_2)),
            style = MaterialTheme.typography.labelMedium.copy(
                shadow = Shadow(
                    color = Color.Black.copy(alpha = 0.7f),
                    offset = Offset(1f, 1f),
                    blurRadius = 2f
                )
            )
        )
    }
}

@Composable
fun TopBar(score: Int, onBackClick: () -> Unit) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp),
        horizontalArrangement = Arrangement.SpaceBetween,
        verticalAlignment = Alignment.CenterVertically
    ) {
        // زر الرجوع
        Box(
            modifier = Modifier
                .size(48.dp)
                .shadow(8.dp, RoundedCornerShape(8.dp))
                .clip(RoundedCornerShape(8.dp))
                .background(Color(0xFF3A9CFF))
                .clickable { onBackClick() }
                .padding(8.dp),
            contentAlignment = Alignment.Center
        ) {
            Icon(
                Icons.AutoMirrored.Filled.ArrowBack,
                contentDescription = "Back",
                tint = Color.White,
                modifier = Modifier.size(24.dp)
            )
        }

        // عرض النقاط
        Row(
            verticalAlignment = Alignment.CenterVertically,
            modifier = Modifier
                .clip(RoundedCornerShape(16.dp))
                .background(
                    Brush.horizontalGradient(
                        colors = listOf(Color(0xFF2E59BC), Color(0xFF0C1B35))
                    )
                )
                .border(1.dp, Color(0xFF4C7CE4), RoundedCornerShape(16.dp))
                .padding(horizontal = 12.dp, vertical = 8.dp)
        ) {
            Image(
                painter = painterResource(id = R.drawable.coin_ic),
                contentDescription = "Coins",
                modifier = Modifier.size(24.dp)
            )
            Text(
                text = score.toString(),
                color = Color.White,
                fontSize = 18.sp,
                fontWeight = FontWeight.Bold,
                modifier = Modifier.padding(start = 8.dp, end = 8.dp)
            )
            Box(
                modifier = Modifier
                    .size(24.dp)
                    .clip(CircleShape)
                    .background(Color(0xFF4CAF50)),
                contentAlignment = Alignment.Center
            ) {
                Text(
                    text = "+",
                    color = Color.White,
                    fontSize = 16.sp,
                    fontWeight = FontWeight.Bold
                )
            }
        }
    }
}
@Composable
fun ProgressIndicator(currentLevel: Int, maxLevel: Int, modifier: Modifier = Modifier) {
    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        modifier = modifier,
        verticalArrangement = Arrangement.Center
    ) {
        Box(
            modifier = Modifier
                .width(48.dp)
                .padding(bottom = 6.dp),
            contentAlignment = Alignment.Center
        ) {
            Text(
                text = "$currentLevel/$maxLevel",
                color = Color.White,
                fontSize = 12.sp,
                fontWeight = FontWeight.Bold,
                modifier = Modifier
                    .background(Color(0x88000000), RoundedCornerShape(8.dp))
                    .border(1.dp, Color(0xFF4C7CE4), RoundedCornerShape(8.dp))
                    .padding(horizontal = 6.dp, vertical = 2.dp)
            )
        }

        Box(
            modifier = Modifier.height(120.dp)
        ) {
            Box(
                modifier = Modifier
                    .width(30.dp)
                    .height(120.dp)
                    .clip(RoundedCornerShape(16.dp))
                    .border(2.dp, Color(0xFF3A9CFF), RoundedCornerShape(16.dp))
                    .background(Color(0x443A9CFF))
            )

            Box(
                modifier = Modifier
                    .width(24.dp)
                    .height(110.dp)
                    .clip(RoundedCornerShape(12.dp))
                    .background(Color(0x22FF4444))
                    .align(Alignment.Center)
            )
            val progress = currentLevel.toFloat() / maxLevel.toFloat()
            Box(
                modifier = Modifier
                    .width(24.dp)
                    .height(110.dp * progress)
                    .clip(RoundedCornerShape(12.dp))
                    .background(
                        Brush.verticalGradient(
                            colors = listOf(Color(0xFFFF6B6B), Color(0xFFFF4444))
                        )
                    )
                    .align(Alignment.BottomCenter)
            )
        }

        Spacer(
            modifier = Modifier
                .height(8.dp)
                .width(48.dp)
        )
        Text(
            text = "ممتلئ",
            color = Color.White,
            fontSize = 16.sp,
            fontFamily = FontFamily(Font(R.font.arbic_font_bold_2)),
            modifier = Modifier
                .padding(horizontal = 8.dp, vertical = 4.dp)
        )
    }
}


@Composable
fun QuestionBar() {
    Box(
        modifier = Modifier
            .fillMaxWidth()
            .height(64.dp)
            .background(
                Brush.verticalGradient(
                    colors = listOf(
                        Color(0xFF1F3677),
                        Color(0xFF0E1E58)
                    )
                )
            ),
        contentAlignment = Alignment.Center
    ) {
        Text(
            text = "ما هو اسم هذه الدولة؟",
            color = Color.White,
            fontSize = 22.sp,
            fontFamily = FontFamily(Font(R.font.arbic_font_bold_2)),
            fontWeight = FontWeight.Bold,
            textAlign = TextAlign.Center,
            style = MaterialTheme.typography.titleLarge.copy(
                shadow = Shadow(
                    color = Color.Black.copy(alpha = 0.7f),
                    offset = Offset(1f, 1f),
                    blurRadius = 3f
                )
            )
        )
    }
}

@Composable
fun ControlButtons(
    onHintClick: () -> Unit,
    onSkipClick: () -> Unit,
    onDeleteLetter: () -> Unit,
    onClearAll: () -> Unit,
    onDeleteRandomLetters: () -> Unit,
    isDeleteRandomEnabled: Boolean
) {
    Box(
        modifier = Modifier
            .fillMaxWidth()
            .height(120.dp)
            .background(Color(0xFF0C1638))
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 8.dp, vertical = 8.dp),
            horizontalArrangement = Arrangement.SpaceEvenly,
            verticalAlignment = Alignment.CenterVertically
        ) {
            ControlButton(
                iconRes = R.drawable.idea_ic,
                backgroundColor = Color(0xFF4CAF50),
                onClick = onHintClick,
                label = "تلميح"
            )

            ControlButton(
                iconRes = R.drawable.arrow_forward_ic,
                backgroundColor = Color(0xFF9C27B0),
                onClick = onSkipClick,
                label = "تخطي"
            )

            ControlButton(
                iconRes = R.drawable.close_ic,
                backgroundColor = Color(0xFFE91E63),
                onClick = onDeleteLetter,
                label = "حذف"
            )

            ControlButton(
                iconRes = R.drawable.refresh_ic,
                backgroundColor = Color(0xFFFF5722),
                onClick = onClearAll,
                label = "إعادة"
            )

            ControlButton(
                iconRes = R.drawable.close_ic,
                backgroundColor = Color(0xFF2196F3),
                onClick = onDeleteRandomLetters,
                label = "حذف حرفين",
                enabled = isDeleteRandomEnabled
            )
        }
    }
}

@Composable
fun SuccessMessage(score: Int) {
    var scale by remember { mutableStateOf(0f) }

    LaunchedEffect(Unit) {
        animate(
            initialValue = 0f,
            targetValue = 1f,
            animationSpec = tween(durationMillis = 300, easing = FastOutSlowInEasing)
        ) { value, _ ->
            scale = value
        }
    }

    Box(
        modifier = Modifier
            .size(280.dp)
            .scale(scale)
            .shadow(16.dp, RoundedCornerShape(24.dp))
            .clip(RoundedCornerShape(24.dp))
            .background(
                Brush.radialGradient(
                    colors = listOf(
                        Color(0xFF4CAF50),
                        Color(0xFF388E3C)
                    )
                )
            )
            .border(2.dp, Color.White, RoundedCornerShape(24.dp)),
        contentAlignment = Alignment.Center
    ) {
        Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center
        ) {
            Icon(
                imageVector = Icons.Default.Check,
                contentDescription = "Success",
                tint = Color.White,
                modifier = Modifier.size(80.dp)
            )

            Spacer(modifier = Modifier.height(16.dp))

            Text(
                text = "ممتاز!",
                color = Color.White,
                fontSize = 32.sp,
                fontFamily = FontFamily(Font(R.font.arbic_font_bold_2)),
                fontWeight = FontWeight.Bold,
                textAlign = TextAlign.Center
            )

            Spacer(modifier = Modifier.height(8.dp))

            Text(
                text = "+$score نقطة",
                color = Color.Yellow,
                fontSize = 24.sp,
                fontFamily = FontFamily(Font(R.font.arbic_font_bold_2)),
                fontWeight = FontWeight.Bold,
                textAlign = TextAlign.Center
            )
        }
    }
}

@Composable
fun ErrorMessage() {
    var scale by remember { mutableStateOf(0f) }

    LaunchedEffect(Unit) {
        animate(
            initialValue = 0f,
            targetValue = 1f,
            animationSpec = tween(durationMillis = 300, easing = FastOutSlowInEasing)
        ) { value, _ ->
            scale = value
        }
    }

    Box(
        modifier = Modifier
            .size(220.dp)
            .scale(scale)
            .shadow(16.dp, RoundedCornerShape(24.dp))
            .clip(RoundedCornerShape(24.dp))
            .background(
                Brush.radialGradient(
                    colors = listOf(
                        Color(0xFFF44336),
                        Color(0xFFD32F2F)
                    )
                )
            )
            .border(2.dp, Color.White, RoundedCornerShape(24.dp)),
        contentAlignment = Alignment.Center
    ) {
        Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center
        ) {
            Icon(
                imageVector = Icons.Default.Close,
                contentDescription = "Error",
                tint = Color.White,
                modifier = Modifier.size(72.dp)
            )

            Spacer(modifier = Modifier.height(16.dp))

            Text(
                text = "حاول مرة أخرى!",
                color = Color.White,
                fontSize = 24.sp,
                fontFamily = FontFamily(Font(R.font.arbic_font_bold_2)),
                fontWeight = FontWeight.Bold,
                textAlign = TextAlign.Center
            )
        }
    }
}

@Preview(showBackground = true)
@Composable
fun WordGuessingGamePreview() {
    WordGuessingGameApp()
}

// تحديث مكون GuessingArea
@Composable
fun GuessingArea(
    targetWord: String,
    selectedLetters: List<LetterData>,
    availableLetters: List<LetterData>,
    onLetterSelected: (LetterData) -> Unit,
) {
    Box(
        modifier = Modifier
            .fillMaxWidth()
            .height(280.dp)
            .background(
                Brush.verticalGradient(
                    colors = listOf(Color(0xFF13277A), Color(0xFF0E1E58))
                )
            ),
        contentAlignment = Alignment.Center
    ) {
        Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.spacedBy(16.dp),
            modifier = Modifier.padding(vertical = 16.dp)
        ) {
            Row(
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                for (i in targetWord.indices) {
                    val hasLetter = i < selectedLetters.size
                    Box(
                        modifier = Modifier
                            .size(44.dp)
                            .clip(RoundedCornerShape(8.dp))
                            .background(
                                if (hasLetter) Color.White
                                else Color(0xFF3A5498)
                            )
                            .border(1.dp, Color(0xFF5270BF), RoundedCornerShape(8.dp)),
                        contentAlignment = Alignment.Center
                    ) {
                        if (hasLetter) {
                            Text(
                                text = selectedLetters[i].letter.toString(),
                                color = Color.Black,
                                fontSize = 24.sp,
                                fontFamily = FontFamily(Font(R.font.arbic_font_bold_2)),
                                fontWeight = FontWeight.Bold
                            )
                        }
                    }
                }
            }

            Column(
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Row(
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    for (i in 0 until 5) {
                        ArabicLetterButton(
                            letter = availableLetters[i].letter.toString(),
                            onClick = { onLetterSelected(availableLetters[i]) },
                            isSelected = availableLetters[i].isSelected,
                            isDeleted = availableLetters[i].isDeleted
                        )
                    }
                }
                Row(
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    for (i in 5 until availableLetters.size) {
                        ArabicLetterButton(
                            letter = availableLetters[i].letter.toString(),
                            onClick = { onLetterSelected(availableLetters[i]) },
                            isSelected = availableLetters[i].isSelected,
                            isDeleted = availableLetters[i].isDeleted
                        )
                    }
                }
            }
        }
    }
}
// تحديث ArabicLetterButton للتعامل مع حالات مختلفة
@Composable
fun ArabicLetterButton(
    letter: String,
    onClick: () -> Unit,
    isSelected: Boolean = false,
    isDeleted: Boolean = false
) {
    val infiniteTransition = rememberInfiniteTransition(label = "pulse")
    val scale by infiniteTransition.animateFloat(
        initialValue = 1f,
        targetValue = if (!isSelected && !isDeleted) 1.05f else 1f,
        animationSpec = infiniteRepeatable(
            animation = tween(1000, easing = LinearEasing),
            repeatMode = RepeatMode.Reverse
        ),
        label = "scale"
    )

    Box(
        modifier = Modifier
            .size(48.dp)
            .scale(scale)
            .shadow(4.dp, RoundedCornerShape(8.dp))
            .clip(RoundedCornerShape(8.dp))
            .background(
                when {
                    isDeleted -> Brush.radialGradient(
                        colors = listOf(
                            Color(0x44CCCCCC),
                            Color(0x44CCCCCC)
                        )
                    )
                    isSelected -> Brush.radialGradient(
                        colors = listOf(
                            Color(0xFF0E1E58),
                            Color(0xFF0E1E58)
                        )
                    )
                    else -> Brush.radialGradient(
                        colors = listOf(Color.White, Color(0xFFF0F0F0))
                    )
                }
            )
            .clickable(
                enabled = !isSelected && !isDeleted,
                onClick = onClick
            ),
        contentAlignment = Alignment.Center
    ) {
        Text(
            text = if (isDeleted) "" else letter,
            color = if (isSelected)
                Color(0xFF0E1E58) else Color.Black,
            fontSize = 26.sp,
            fontFamily = FontFamily(Font(R.font.arbic_font_bold_2)),
            fontWeight = FontWeight.Bold,
            textAlign = TextAlign.Center
        )
    }
}